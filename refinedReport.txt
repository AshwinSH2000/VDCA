Methodology (how you are going to achieve the objectives)

This section outlines the entire methodology used to develop interactive visualisations for three use-cases of divide and conquer algorithms: Quicksort, Convex Hull, and Binary Tree Construction. These visualizations were created with the goal of helping users get a deeper conceptual understanding of recursion and divide-and-conquer algorithms through an intuitive, step-by-step interface.

Quicksort
Methodology:
The user is given the liberty to input as many numbers as they wish. These numbers need to be entered either as comma-separated or space-separated values. Once done, they can either click the 'Insert' button present on the screen or press 'Enter/Return' key on the keyboard. Upon submission, grey rectangular bars are rendered on the screen at the center. The height of each bar corresponds to the value of the respective number entered. These bars are rendered in the same order in which the user entered those numbers.

Once the user has provided the desired numbers to sort, two options are available—'Divide' and 'Solve'. At this point, the 'Conquer' button remains disabled as it is not possible to perform the conquer step before any divide is performed. If the user clicks 'Solve', the original grey bars are shifted to the left half of the screen and the final sorted array is displayed instantly on the right half of the screen without any intermediate steps. On the other hand, if the user clicks 'Divide', it initiates the divide-and-conquer process. This makes the algorithm select a pivot element using the 'Median of 3' strategy. This involves selecting the first, middle, and last elements of the array, sorting them in ascending order and choosing the median value as the pivot. Some other common strategies to choose the pivot element are picking the first element of the array, the last element of the array etc. However those methods result in the sorting algorithm degrading to the worst case time complexity of O(n^2) in case the provided array is already sorted or fully reverse sorted. By opting for 'Median of 3' strategy, it is more likely to select a pivot closer to the true median, which results in a more balanced partitions and maintains O(nlogn) average-case efficiency.

The next step after selecting the pivot element is to rearrange the array so that all elements smaller than the pivot are placed to its left and all larger elements are placed to its right. After the rearrangement, a new set of rectangular bars is drawn below the original input bars. The pivot is highlighted with a different colour and is placed with a wider gap from all other elements. The colour of each pivot bar is based on the depth/level in which it was picked. Each time the user clicks on 'Divide' the variable 'level' is increased to keep track of pivots as mentioned above. These levels represent how deep the partitions have gone— 'level 0' being the first time the user clicks 'Divide', 'level 1' the next, and so on. The colour codes of bars are such that pivot chosen in level 0 is represented in red, in level 1 is blue, in level 2 is green, level 3 is orange, level 4 is brown, level 5 s violet, and lastly level 6 - greenyellow. (Think of adding how you will manage more level colours...remember the bug?)

As the new set of bars is rendered, two partitions become clearly visible, with the pivot element separating them. When the user clicks 'Divide' again (i.e., level 1), each partition is treated as a subarray, and the same pivot-selection and rearrangement process is applied to each subarray. Each time this happens, new rows of rectangular bars are drawn below the previous row of bars. The pivots in each of these rows are highlighted with different colours (as shown in image). After each partitioning, the algorithm checks if it is possible to partition the array further. It is possible if there is at least one subarray that has two or more elements. If not, it implies that every element is either chosen as a pivot or is alone in its own subarray. At this point, the 'Divide' button is disabled and only the 'Solve' button remains enabled.

Clicking the 'Solve' button at any stage after clicking on 'Divide' at least once generates the intermediate solution based on the partitions created until that point. If clicked after all divide steps are completed, it takes the process to the conquer stage and displays the sorted array on the right side of the last row of bars created. Since the array is already sorte when the divide phase is completed, clicking 'Solve' here performs no additional computation. However, in this case, the 'Solve' button becomes disabled and the 'Conquer' button is enabled instead.

This behavior, where the array is already sorted at the end of the divide phase, is intentional. It helps show how the divide-and-conquer strategy works. To clarify this, during the divide phase, pivot elements have unique colors and spacing to mark the partition boundaries clearly as mentioned previously. In the conquer phase, these pivot bars are reverted to their default grey colour, and their spacing is reduced to blend them back into the final sorted array. Each time the user clicks 'Conquer' button, the pivots selected in the corresponding divide step are merged back into the array. As the user continues clicking 'Conquer', the pivots are visually removed one by one, and by the final conquer step, the fully sorted array is shown as a single row of grey bars, signifying the completion of the sorting process.

To help the user track their interactions and keep themselves informed of what has happened in the visualiser, toast messages and logs option is included in the visualiser. The toast message displays the actions performed by the user along with the corresponding computational steps performed by the system. It is also colour coded for different types of messages-red for error messages, green for success messages and light grey for normal informations. These messages are programmed to stay on the screen for 10 seconds and disappear. Once it leaves the screen, it will be displayed in the logs panel. The logs panel can be accessed anytime by clicking on 'Logs' button. To illustrate the functioning, when the user clicks divide, it shows which element was chosen as a pivot and what the three elements were whose median was used to select the pivot. When the user enters or deletes the numbers initially logs insertions or deletions from the input array. It also indicates when the divide phase completes and, during the conquer phase, it logs the merging of partitions and the final successful sorting step. Whenever a new toast message needs to be displayed, it replaces the existing toast message. However, the old message can still be viewed through the logs panel.

As this tool can be used by students who do not have a full working knowledge of quicksort, it includes an FAQs section. This section explains what quicksort is, how the pivot is chosen and how divide and conquer algorithm is applied to perform sorting. It also answers many questions that users may have regarding the interface such as the meaning of the different coloured bars, disabling of buttons based on the execution timeline and also describes the functionalities of various interface components like buttons and logs.

Additionally, a 'Guide Me!' button is available to assist users interactively. Clicking this button displays tooltips explaining the functions of each interactive component on the screen. Each tooltip consists of the explaination text along with '->', '<-' and 'x' used to go to next, previous tip and to close the tips totally. Users can navigate these tips at their own pace. These tips can be invoked at any point during execution, ensuring users can understand the purpose and effect of each button whenever needed.

---

Convex hull:

For any given point or set of points, the convex hull is the smallest set of points such that drawing a boundary around them encloses all the points, forming a convex polygon. A convex polygon is one where all interior angles are less than 180 degrees, meaning that all vertices point outward and no angle “caves in.” While humans can easily identify the convex hull visually, it is not straightforward for a computer to do the same. To determine the convex hull computationally, the algorithm applies the divide and conquer technique recursively.

The overall idea is to divide the set of points into smaller partitions using perfect vertical lines until each partition contains only one or two points. In the special case of exactly vertical collinear points, the partitions may contain more than two points, as dividing them further using vertical lines is not possible. The base cases for convex hulls are either a single point or a line segment connecting two points. In the special collinear case, the base case consists of the line joining all the vertical collinear points.

The execution begins with the user clicking on the intersections of the grid. The grid's dimension is 11x11 and the user can click on any of the 121 points available. If the click is near the intersection, then the point is registered and a toast message gets displayed mentioning the same. However, if the user clicks further away from the intersection, the an error toast message is displayed which asks the user to click closer to the intersection. The user has the freedom to select any number of points to draw the convex hull. Once all the points are clicked, they again have two optopns initially - Divide and Solve. Clicking on solve immediately displays the convex hull for the entered points without displaying any intermediate steps.

To begin the partitioning, the algorithm filters the set of points based on their sorted, unique x-coordinates (sortedUniqueXCoords). The y-coordinates are not yet considered at this stage. For instance, consider the points [5,2], [7,1], [7,2], [7,3], [9,1], [9,2], and [9,3] to be in the coordinates array. There are multiple points having the same x-coordinates but different y-coordinate, meaning they are collinear. Therefore, the sortedUniqueXCoords of this set of points would be [5, 7, 9], representing projections of the points onto the x-axis. The partitioning is then done by splitting sortedUniqueXCoords. If there are even number of elements, both the partitions will consist of equal number of elements after splitting; if odd, the right partition receives one more element than the left. In this case, x = 5 would be in the left partition, while x = 7 and x = 9 would fall in the right partition. The important thing to note is that, while splitting, the actual coordinates array is not considered.

Similar to how the pivot elements are colour coded in quicksort, the partitioning lines are color-coded according to the level at which the division occurs. The 'level' variable is incremented each time the user clicks on 'Divide' button. Red colour is used to draw the partition line generated in level 0, blue for level 1, yellow for level 2, and cyan for level 3. Since the grid size is 11x11, there are 121 points the user can click on. Only one partition is possible in level 0, up to a maximum of two new partitions in level 1, up to four in level 2, and up to eight in level 3. However, given the space constraints, only three more new partitions can be added at level 3, despite its theoretical capacity of eight.

If additional divides are possible, the process continues. In the previous example, the new sorted x-coordinates for the right side become [7, 9], since x = 5 has already reached its base case. A blue dotted line is drawn between 7 and 9. Since these points are vertically collinear, further division is not possible, and the divide phase concludes. However, for other examples, if further division is possible, partition lines will continue to appear, colored based on their respective divide level. Once all possible divide operations are complete, the "Divide" button is disabled.

At this point, only the "Solve" button remains enabled. Clicking it displays the base case convex hulls for each partition—lines for partitions containing two points and single points for singleton partitions. After this step, the "Solve" button is disabled and the "Conquer" button becomes active. Clicking "Conquer" triggers the merging of convex hulls in reverse order of their creation. As each merge is performed, the resulting hull grows in size. The in-focus partition lines and hulls are displayed with solid, brightly colored lines, while out-of-focus elements are shown using dull, dotted lines. During each conquer step, the convex hulls across partition lines are joined, and their colors update to match the previous divide level. This process continues until the final convex hull is drawn in green.

The merging of convex hulls at each conquer step follows a specific algorithm. Given two sets of points to merge, the algorithm selects the rightmost point from the left set (say pt1) and the leftmost point from the right set (say pt2). With pt1 and pt2 fixed, it iterates over all points in the right set to find the topmost point such that the lines joining pt1, pt2, and a new point turns towards the top direction. Existence of such a point indicates that there is another point that is above pt2. When such a point is found, it is updated as pt2, and the process continues until there is no change in pt2. When this loop finally breaks, topmost point in the right set is identified as pt2. The same process is repeated on the left set to search and update pt1. This results in pt1 and pt2 marking the end points of top tangent between the two sets and no points lie above this line. A common doubt that generally comes to people is why we need to do such a lengthy process to find the top tangent. Why cant we just findout and choose the topmost point in each of the set of points? The answer lies in the fact that sometimes, the line drawn through the topmost point of a set might not lie above all the points in both the sets as shown in the figure x.

The algorithm then executes a similar loop to find the bottom tangent. This time, it looks for points that make the lines turn towards the bottom—essentially the inverse of the process for the top tangent. Once both tangents are found, the end points define the corners of a quadrilateral. The algorithm then checks all other points to determine if they lie within this polygon. If a point is inside or on the edge, it is ignored. If it lies outside, it becomes part of the final convex hull edge. The original coordinates array is then updated with the new hull points, and this process repeats with each conquer operation until only one set remains.

In some cases, the top and bottom tangent points in one or both of the hulls may be the same, reducing the quadrilateral to a triangle or simply a line. However, the algorithm still functions exactly as stated above. Such cases can arise if all the points in one or both the sets are horizontally collinear.

The "Solve" button allows users to reach the solution quickly. If used before any divide operation, it computes and displays the convex hull of all the points instantly without visualising any of the intermediate steps. If used after completing all divide operations, it reveals the base case solutions. When used at any intermediate stage, it displays convex hulls for the partitions already created. The user cannot skip the "Solve" step; after all divide operations are completed, it is the only available button and must be clicked to proceed.

Similar to the quicksort visualizer, this tool includes a logging feature. Every time a user clicks on a point, a message is logged to indicate that the point was added to the array. Clicking on the same point again removes it and logs a delete message. If a user clicks somewhere not aligned with the grid, an error message is displayed, asking the user to click closer to the intersection of the grid lines. During the divide phase, logs indicate the x-coordinates where partitioning occurred, and during the conquer phase, the x-coordinates of the merged partitions. Success messages are also shown when the divide or conquer phases are completed.

The visualizer also includes an FAQ page to help users understand what convex hulls are and how the divide and conquer algorithm is implemented in this tool. Additionally, there is a "Guide Me!" button that activates tooltips explaining the functionality of each button in the interface. Users can navigate through these tips using left and right arrows or close them using the "x" button. Tooltips also close automatically upon reaching the final tip. These guides can be accessed at any point during execution to assist users in understanding the interface. Lastly, a "Reset" button is provided to reset the entire interface. Buttons within the visualizer are dynamically enabled or disabled based on the current state of the algorithm.

---

Binary Tree Construction

Inorder traversal is defined as a way to represent all the nodes of a tree in the order: left child → root → right child. If any child has its own children, the same traversal pattern is applied recursively. For example, the binary tree shown in figure x has the inorder traversal: 4 2 5 1 6 3 7

On the other hand, preorder traversal is another way to represent all the nodes in a slightly different order: root → left child → right child. Again, this pattern is recursively applied to each subtree. For the same tree in figure x, the preorder traversal is: 1 2 4 5 3 6 7

When inorder and preorder traversals of any tree is given, the binary tree can be uniquely reconstructed. The core idea is to use the preorder traversal to recursively identify the root of the tree and then use the inorder traversal to divide the nodes into left and right subtrees.

The users can enter these traversals in its respective text boxes as comma or space separated values and click 'Insert'. This action prints the inorder and preorder traversals in the left-hand side of the screen. The algorithm starts by validating the user input to ensure that a valid tree can actually be constructed from the given traversals. If not, it immediately displays a toast message indicating the issue and clears the inputs. If the input is valid, the algorithm proceedes and waits for the user to click on 'Divide' or 'Solve'. Clicking 'Solve' at this point directly displays the final tree without showing any intermediate steps of dividing the inputs or building the tree step by step.

If the user clicks 'Divide' the algorithm initially extracts the first element in the preorder traversal which is always the root of the binary tree. Let's call this element `x`. It then locates `x` in the inorder traversal. All elements to the left of `x` form the left subtree, and all elements to the right form the right subtree. This is represented by printing the inorder and preorder traversals below the original inputs with the root element highlighted with a unique colour. These two parts become sub-inorder traversals. These sub-inorder traversals are actually a subtree of the main binary tree that is being constructed.

The elements in each sub-inorder appear together in the preorder traversal although not in the same order. This is shown in figure y. The first element from each of these partitions in the preorder traversal is the root of the corresponding subtree. This process is repeated recursively: at each step, we find the root from the preorder list and use it to partition the current inorder segment. This process is terminated when only one element remains in a partition and this element is a leaf node. At this point, the divide phase is completed and only 'Solve' button remains enabled. Clicking on that will display the leaf nodes on the right hand side of the screen. After this, the user can only click on 'Conquer' button. With each click of 'Conquer' button, the tree gets built in reverse: from the leaves back up to the root, connecting nodes level by level.

The visualiser keeps a global 'level' variable and it is incremented each time the user clicks on 'Divide'. During the conquer phase, it gets decremented with each click of 'Conquer' button. The conquer function draws the nodes that were identified in each level and then call another function to draw the lines between the parent and child nodes. This function's working is explained further below. Conquer function starts from the maximum value of level reached during divide and decrements with each "Conquer" click.

A custom class (called Node) is defined to represent each node of the binary tree. It has three fields: value, left and right. 'Value' stores the integer at that node. 'left' stores the left child node (default = null). 'right' stores the right child node (default null)
During the divide phase, whenever a new root is identified, a class object is created with its `value`, and the `left` and `right` fields are initially null. This node is then attached to its parent, either on the left or right, based on its position in the inorder traversal. Hence when the divide phase is complete, technically, the tree would have been fully constructed in memory. This means the nodes at each level would have been attached to its parent and/or child nodes. The function to draw the lines between nodes refers to this class to gather information about the child and parent nodes.

To aid in the visualization, each traversal element has a 'displayed' flag indicating whether it has been identified as a root, and a 'level' variable indicating the level.
At each level(global), The algorithm scans all nodes and draws the ones found at the current level. These nodes are rendered in the order of the inorder traversal.
These 'displayed' and 'level(local)' fields are monitored as shown below to control how traversal numbers are displayed:

1. If `flag` is `false`: the number hasn’t been used as a root yet, so it’s shown in black colour.
2. If `flag` is `true` and the current level matches its recorded level: show it with a distinct color.
3. If `flag` is `true` but from a different level: replace it with a blank space to visually indicate a split.

For example, if the inorder traversal is **4 2 5 1 6 3 7**, and the leaf nodes are **4, 5, 6, and 7**, then the first conquer step will draw these four nodes in this order. Other nodes (like 1, 2, 3) are not drawn at this point since their `level` does not match the current one.

Similar to the other two examples, the element(s) that is identified as the root are displayed using different colours. These colours are red, blue, green, yellow, cyan, white, pink, purple, brown and grey for levels starting from 0 all the way to 9.

After nodes are drawn, a function checks if arrows (edges) need to be added. For this, it consults the class Node as mentioned above. It scans through the nodes that were just rendered on screen and checks if these nodes have any child nodes. If they do not have any such nodes, it simply returns. Else, it draws the required lines as follows. But before that let me briefly explain where these nodes and lines will be drawn.

The entire drawing area is a large HTML `div` container. Circular nodes are placed on smaller overlaid `div`s corresponding to their level. So to visualise this, there is a large div covering the entire right hand side of the viewport and above that there are dynamically created smaller divs in which the circular nodes are printed.
To draw lines between parent and child nodes, the algorithm retrieves the bottom-center coordinates of the parent and top-center coordinates of child node(s). Since the parent and child nodes are present in different divs, their coordinates will be local to that div. The function then translates these into coordinates relative to the larger div container. Then it proceedes to draws the connecting lines on the larger div which gives the viewer an impression that the smaller overlapping divs are connected.
An update function is also triggered at the end of this function to re-draw arrows if node positions shift due to new elements being added.

When the user clicks on 'Conquer' repeatedly, the algorithm builds the tree step by step from the bottom. The top most node will have the same colour its corresponding divide step. Once a new node is attached to the top, all older nodes are coloured black to signify that these nodes are not in focus anymore. Once the final tree is constructed, all the nodes are shown in black colour.

Just like the previous two examples, this visualisation also has the FAQs page that informs the users about the concepts of binary tree construction, how is divide and conquer algorithm applied here and such similaar questions. They also have the same feature provided by the 'Guide Me!' button which helps them navigate the interface using tips. These tips stay in place until the user interacts with them using one of the next, previous and close buttons.

Just like the other two examples, there is also the toast message functionality. This informs the users about the results of the actions they performed and also informs them about any success/error messages using the same three colour coded messages. These toast messages stay for 10 secones and beyond that they will be safely stored under the logs button. The users can access the logs functionality at any point in the execution to stay informed about the current state of the visualisation.
