Methodology (how you are going to achieve the objectives)

This section outlines the entire methodology used to develop interactive visualisations for three use-cases of divide and conquer algorithms: Quicksort, Convex Hull, and Binary Tree Construction. These visualisations were created with the goal of helping users get a deeper conceptual understanding of recursion and divide-and-conquer algorithms through an intuitive, step-by-step interface.

Quicksort
Methodology:
The user is given the liberty to input as many numbers as they wish. These numbers need to be entered either as comma-separated or space-separated values. Once done, they can either click the 'Insert' button present on the screen or press 'Enter/Return' key on the keyboard. Upon submission, grey rectangular bars are rendered on the screen at the center. The height of each bar corresponds to the value of the respective number entered. These bars are rendered in the same order in which the user entered those numbers.

Once the user has provided the desired numbers to sort, two options are available—'Divide' and 'Solve'. At this point, the 'Conquer' button remains disabled as it is not possible to perform the conquer step before any divide is performed. If the user clicks 'Solve', the original grey bars are shifted to the left half of the screen and the final sorted array is displayed instantly on the right half of the screen without any intermediate steps. On the other hand, if the user clicks 'Divide', it initiates the divide-and-conquer process. This makes the algorithm select a pivot element using the 'Median of 3' strategy. This involves selecting the first, middle, and last elements of the array, sorting them in ascending order and choosing the median value as the pivot. Some other common strategies to choose the pivot element are picking the first element of the array, the last element of the array etc. However those methods result in the sorting algorithm degrading to the worst case time complexity of O(n^2) in case the provided array is already sorted or fully reverse sorted. By opting for 'Median of 3' strategy, it is more likely to select a pivot closer to the true median, which results in a more balanced partitions and maintains O(nlogn) average-case efficiency.

The next step after selecting the pivot element is to rearrange the array so that all elements smaller than the pivot are placed to its left and all larger elements are placed to its right. After the rearrangement, a new set of rectangular bars is drawn below the original input bars. The pivot is highlighted with a different colour and is placed with a wider gap from all other elements. The colour of each pivot bar is based on the depth/level in which it was picked. Each time the user clicks on 'Divide' the variable 'level' is increased to keep track of pivots as mentioned above. These levels represent how deep the partitions have gone— 'level 0' being the first time the user clicks 'Divide', 'level 1' the next, and so on. The colour codes of bars are such that pivot chosen in level 0 is represented in red, in level 1 is blue, in level 2 is green, level 3 is orange, level 4 is brown, level 5 s violet, and lastly level 6 - greenyellow. (Think of adding how you will manage more level colours...remember the bug?)

As the new set of bars is rendered, two partitions become clearly visible, with the pivot element separating them. When the user clicks 'Divide' again (i.e., level 1), each partition is treated as a subarray, and the same pivot-selection and rearrangement process is applied to each subarray. Each time this happens, new rows of rectangular bars are drawn below the previous row of bars. The pivots in each of these rows are highlighted with different colours (as shown in image). After each partitioning, the algorithm checks if it is possible to partition the array further. It is possible if there is at least one subarray that has two or more elements. If not, it implies that every element is either chosen as a pivot or is alone in its own subarray. At this point, the 'Divide' button is disabled and only the 'Solve' button remains enabled.

Clicking the 'Solve' button at any stage after clicking on 'Divide' at least once generates the intermediate solution based on the partitions created until that point. If clicked after all divide steps are completed, it takes the process to the conquer stage and displays the sorted array on the right side of the last row of bars created. Since the array is already sorte when the divide phase is completed, clicking 'Solve' here performs no additional computation. However, in this case, the 'Solve' button becomes disabled and the 'Conquer' button is enabled instead.

This behavior, where the array is already sorted at the end of the divide phase, is intentional. It helps show how the divide-and-conquer strategy works. To clarify this, during the divide phase, pivot elements have unique colors and spacing to mark the partition boundaries clearly as mentioned previously. In the conquer phase, these pivot bars are reverted to their default grey colour, and their spacing is reduced to blend them back into the final sorted array. Each time the user clicks 'Conquer' button, the pivots selected in the corresponding divide step are merged back into the array. As the user continues clicking 'Conquer', the pivots are visually removed one by one, and by the final conquer step, the fully sorted array is shown as a single row of grey bars, signifying the completion of the sorting process.

To help the user track their interactions and keep themselves informed of what has happened in the visualiser, toast messages and logs option is included in the visualiser. The toast message displays the actions performed by the user along with the corresponding computational steps performed by the system. It is also colour coded for different types of messages-red for error messages, green for success messages and light grey for normal informations. These messages are programmed to stay on the screen for 10 seconds and disappear. Once it leaves the screen, it will be displayed in the logs panel. The logs panel can be accessed anytime by clicking on 'Logs' button. To illustrate the functioning, when the user clicks divide, it shows which element was chosen as a pivot and what the three elements were whose median was used to select the pivot. When the user enters or deletes the numbers initially logs insertions or deletions from the input array. It also indicates when the divide phase completes and, during the conquer phase, it logs the merging of partitions and the final successful sorting step. Whenever a new toast message needs to be displayed, it replaces the existing toast message. However, the old message can still be viewed through the logs panel.

As this tool can be used by students who do not have a full working knowledge of quicksort, it includes an FAQs section. This section explains what quicksort is, how the pivot is chosen and how divide and conquer algorithm is applied to perform sorting. It also answers many questions that users may have regarding the interface such as the meaning of the different coloured bars, disabling of buttons based on the execution timeline and also describes the functionalities of various interface components like buttons and logs.

Additionally, a 'Guide Me!' button is available to assist users interactively. Clicking this button displays tooltips explaining the functions of each interactive component on the screen. Each tooltip consists of the explaination text along with '->', '<-' and 'x' used to go to next, previous tip and to close the tips totally. Users can navigate these tips at their own pace. These tips can be invoked at any point during execution, ensuring users can understand the purpose and effect of each button whenever needed.

---

Convex hull:

For any given point or set of points, the convex hull is the smallest set of points such that drawing a boundary around them encloses all the points, forming a convex polygon. A convex polygon is one where all interior angles are less than 180 degrees, meaning that all vertices point outward and no angle “caves in.” While humans can easily identify the convex hull visually, it is not straightforward for a computer to do the same. To determine the convex hull computationally, the algorithm applies the divide and conquer technique recursively.

The overall idea is to divide the set of points into smaller partitions using perfect vertical lines until each partition contains only one or two points. In the special case of exactly vertical collinear points, the partitions may contain more than two points, as dividing them further using vertical lines is not possible. The base cases for convex hulls are either a single point or a line segment connecting two points. In the special collinear case, the base case consists of the line joining all the vertical collinear points.

The execution begins with the user clicking on the intersections of the grid. The grid's dimension is 11x11 and the user can click on any of the 121 points available. If the click is near the intersection, then the point is registered and a toast message gets displayed mentioning the same. However, if the user clicks further away from the intersection, the an error toast message is displayed which asks the user to click closer to the intersection. The user has the freedom to select any number of points to draw the convex hull. Once all the points are clicked, they again have two optopns initially - Divide and Solve. Clicking on solve immediately displays the convex hull for the entered points without displaying any intermediate steps.

To begin the partitioning, the algorithm filters the set of points based on their sorted, unique x-coordinates (sortedUniqueXCoords). The y-coordinates are not yet considered at this stage. For instance, consider the points [5,2], [7,1], [7,2], [7,3], [9,1], [9,2], and [9,3] to be in the coordinates array. There are multiple points having the same x-coordinates but different y-coordinate, meaning they are collinear. Therefore, the sortedUniqueXCoords of this set of points would be [5, 7, 9], representing projections of the points onto the x-axis. The partitioning is then done by splitting sortedUniqueXCoords. If there are even number of elements, both the partitions will consist of equal number of elements after splitting; if odd, the right partition receives one more element than the left. In this case, x = 5 would be in the left partition, while x = 7 and x = 9 would fall in the right partition. The important thing to note is that, while splitting, the actual coordinates array is not considered.

Similar to how the pivot elements are colour coded in quicksort, the partitioning lines are color-coded according to the level at which the division occurs. The 'level' variable is incremented each time the user clicks on 'Divide' button. Red colour is used to draw the partition line generated in level 0, blue for level 1, yellow for level 2, and cyan for level 3. Since the grid size is 11x11, there are 121 points the user can click on. Only one partition is possible in level 0, up to a maximum of two new partitions in level 1, up to four in level 2, and up to eight in level 3. However, given the space constraints, only three more new partitions can be added at level 3, despite its theoretical capacity of eight.

If additional divides are possible, the process continues. In the previous example, the new sorted x-coordinates for the right side become [7, 9], since x = 5 has already reached its base case. A blue dotted line is drawn between 7 and 9. Since these points are vertically collinear, further division is not possible, and the divide phase concludes. However, for other examples, if further division is possible, partition lines will continue to appear, colored based on their respective divide level. Once all possible divide operations are complete, the "Divide" button is disabled.

At this point, only the "Solve" button remains enabled. Clicking it displays the base case convex hulls for each partition—lines for partitions containing two points and single points for singleton partitions. After this step, the "Solve" button is disabled and the "Conquer" button becomes active. Clicking "Conquer" triggers the merging of convex hulls in reverse order of their creation. As each merge is performed, the resulting hull grows in size. The in-focus partition lines and hulls are displayed with solid, brightly colored lines, while out-of-focus elements are shown using dull, dotted lines. During each conquer step, the convex hulls across partition lines are joined, and their colors update to match the previous divide level. This process continues until the final convex hull is drawn in green.

The merging of convex hulls at each conquer step follows a specific algorithm. Given two sets of points to merge, the algorithm selects the rightmost point from the left set (say pt1) and the leftmost point from the right set (say pt2). With pt1 and pt2 fixed, it iterates over all points in the right set to find the topmost point such that the lines joining pt1, pt2, and a new point turns towards the top direction. Existence of such a point indicates that there is another point that is above pt2. When such a point is found, it is updated as pt2, and the process continues until there is no change in pt2. When this loop finally breaks, topmost point in the right set is identified as pt2. The same process is repeated on the left set to search and update pt1. This results in pt1 and pt2 marking the end points of top tangent between the two sets and no points lie above this line. A common doubt that generally comes to people is why we need to do such a lengthy process to find the top tangent. Why cant we just findout and choose the topmost point in each of the set of points? The answer lies in the fact that sometimes, the line drawn through the topmost point of a set might not lie above all the points in both the sets as shown in the figure x.

The algorithm then executes a similar loop to find the bottom tangent. This time, it looks for points that make the lines turn towards the bottom—essentially the inverse of the process for the top tangent. Once both tangents are found, the end points define the corners of a quadrilateral. The algorithm then checks all other points to determine if they lie within this polygon. If a point is inside or on the edge, it is ignored. If it lies outside, it becomes part of the final convex hull edge. The original coordinates array is then updated with the new hull points, and this process repeats with each conquer operation until only one set remains.

In some cases, the top and bottom tangent points in one or both of the hulls may be the same, reducing the quadrilateral to a triangle or simply a line. However, the algorithm still functions exactly as stated above. Such cases can arise if all the points in one or both the sets are horizontally collinear.

The "Solve" button allows users to reach the solution quickly. If used before any divide operation, it computes and displays the convex hull of all the points instantly without visualising any of the intermediate steps. If used after completing all divide operations, it reveals the base case solutions. When used at any intermediate stage, it displays convex hulls for the partitions already created. The user cannot skip the "Solve" step; after all divide operations are completed, it is the only available button and must be clicked to proceed.

Similar to the quicksort visualiser, this tool includes a logging feature. Every time a user clicks on a point, a message is logged to indicate that the point was added to the array. Clicking on the same point again removes it and logs a delete message. If a user clicks somewhere not aligned with the grid, an error message is displayed, asking the user to click closer to the intersection of the grid lines. During the divide phase, logs indicate the x-coordinates where partitioning occurred, and during the conquer phase, the x-coordinates of the merged partitions. Success messages are also shown when the divide or conquer phases are completed.

The visualiser also includes an FAQ page to help users understand what convex hulls are and how the divide and conquer algorithm is implemented in this tool. Additionally, there is a "Guide Me!" button that activates tooltips explaining the functionality of each button in the interface. Users can navigate through these tips using left and right arrows or close them using the "x" button. Tooltips also close automatically upon reaching the final tip. These guides can be accessed at any point during execution to assist users in understanding the interface. Lastly, a "Reset" button is provided to reset the entire interface. Buttons within the visualiser are dynamically enabled or disabled based on the current state of the algorithm.

---

Binary Tree Construction

Inorder traversal is defined as a way to represent all the nodes of a tree in the order: left child → root → right child. If any child has its own children, the same traversal pattern is applied recursively. For example, the binary tree shown in figure x has the inorder traversal: 4 2 5 1 6 3 7

On the other hand, preorder traversal is another way to represent all the nodes in a slightly different order: root → left child → right child. Again, this pattern is recursively applied to each subtree. For the same tree in figure x, the preorder traversal is: 1 2 4 5 3 6 7

When inorder and preorder traversals of any tree is given, the binary tree can be uniquely reconstructed. The core idea is to use the preorder traversal to recursively identify the root of the tree and then use the inorder traversal to divide the nodes into left and right subtrees.

The users can enter these traversals in its respective text boxes as comma or space separated values and click 'Insert'. This action prints the inorder and preorder traversals in the left-hand side of the screen. The algorithm starts by validating the user input to ensure that a valid tree can actually be constructed from the given traversals. If not, it immediately displays a toast message indicating the issue and clears the inputs. If the input is valid, the algorithm proceedes and waits for the user to click on 'Divide' or 'Solve'. Clicking 'Solve' at this point directly displays the final tree without showing any intermediate steps of dividing the inputs or building the tree step by step.

If the user clicks 'Divide' the algorithm initially extracts the first element in the preorder traversal which is always the root of the binary tree. Let's call this element `x`. It then locates `x` in the inorder traversal. All elements to the left of `x` form the left subtree, and all elements to the right form the right subtree. This is represented by printing the inorder and preorder traversals below the original inputs with the root element highlighted with a unique colour. These two parts become sub-inorder traversals. These sub-inorder traversals are actually a subtree of the main binary tree that is being constructed.

The elements in each sub-inorder appear together in the preorder traversal although not in the same order. This is shown in figure y. The first element from each of these partitions in the preorder traversal is the root of the corresponding subtree. This process is repeated recursively: at each step, we find the root from the preorder list and use it to partition the current inorder segment. This process is terminated when only one element remains in a partition and this element is a leaf node. At this point, the divide phase is completed and only 'Solve' button remains enabled. Clicking on that will display the leaf nodes on the right hand side of the screen. After this, the user can only click on 'Conquer' button. With each click of 'Conquer' button, the tree gets built in reverse: from the leaves back up to the root, connecting nodes level by level.

The visualiser keeps a global 'level' variable and it is incremented each time the user clicks on 'Divide'. During the conquer phase, it gets decremented with each click of 'Conquer' button. The conquer function draws the nodes that were identified in each level and then call another function to draw the lines between the parent and child nodes. This function's working is explained further below. Conquer function starts from the maximum value of level reached during divide and decrements with each "Conquer" click.

A custom class (called Node) is defined to represent each node of the binary tree. It has three fields: value, left and right. 'Value' stores the integer at that node. 'left' stores the left child node (default = null). 'right' stores the right child node (default null)
During the divide phase, whenever a new root is identified, a class object is created with its `value`, and the `left` and `right` fields are initially null. This node is then attached to its parent, either on the left or right, based on its position in the inorder traversal. Hence when the divide phase is complete, technically, the tree would have been fully constructed in memory. This means the nodes at each level would have been attached to its parent and/or child nodes. The function to draw the lines between nodes refers to this class to gather information about the child and parent nodes.

To aid in the visualisation, each traversal element has a 'displayed' flag indicating whether it has been identified as a root, and a 'level' variable indicating the level.
At each level(global), The algorithm scans all nodes and draws the ones found at the current level. These nodes are rendered in the order of the inorder traversal.
These 'displayed' and 'level(local)' fields are monitored as shown below to control how traversal numbers are displayed:

1. If `flag` is `false`: the number hasn’t been used as a root yet, so it’s shown in black colour.
2. If `flag` is `true` and the current level matches its recorded level: show it with a distinct color.
3. If `flag` is `true` but from a different level: replace it with a blank space to visually indicate a split.

For example, if the inorder traversal is **4 2 5 1 6 3 7**, and the leaf nodes are **4, 5, 6, and 7**, then the first conquer step will draw these four nodes in this order. Other nodes (like 1, 2, 3) are not drawn at this point since their `level` does not match the current one.

Similar to the other two examples, the element(s) that is identified as the root are displayed using different colours. These colours are red, blue, green, yellow, cyan, white, pink, purple, brown and grey for levels starting from 0 all the way to 9.

After nodes are drawn, a function checks if arrows (edges) need to be added. For this, it consults the class Node as mentioned above. It scans through the nodes that were just rendered on screen and checks if these nodes have any child nodes. If they do not have any such nodes, it simply returns. Else, it draws the required lines as follows. But before that let me briefly explain where these nodes and lines will be drawn.

The entire drawing area is a large HTML `div` container. Circular nodes are placed on smaller overlaid `div`s corresponding to their level. So to visualise this, there is a large div covering the entire right hand side of the viewport and above that there are dynamically created smaller divs in which the circular nodes are printed.
To draw lines between parent and child nodes, the algorithm retrieves the bottom-center coordinates of the parent and top-center coordinates of child node(s). Since the parent and child nodes are present in different divs, their coordinates will be local to that div. The function then translates these into coordinates relative to the larger div container. Then it proceedes to draws the connecting lines on the larger div which gives the viewer an impression that the smaller overlapping divs are connected.
An update function is also triggered at the end of this function to re-draw arrows if node positions shift due to new elements being added.

When the user clicks on 'Conquer' repeatedly, the algorithm builds the tree step by step from the bottom. The top most node will have the same colour its corresponding divide step. Once a new node is attached to the top, all older nodes are coloured black to signify that these nodes are not in focus anymore. Once the final tree is constructed, all the nodes are shown in black colour.

Just like the previous two examples, this visualisation also has the FAQs page that informs the users about the concepts of binary tree construction, how is divide and conquer algorithm applied here and such similaar questions. They also have the same feature provided by the 'Guide Me!' button which helps them navigate the interface using tips. These tips stay in place until the user interacts with them using one of the next, previous and close buttons.

Just like the other two examples, there is also the toast message functionality. This informs the users about the results of the actions they performed and also informs them about any success/error messages using the same three colour coded messages. These toast messages stay for 10 secones and beyond that they will be safely stored under the logs button. The users can access the logs functionality at any point in the execution to stay informed about the current state of the visualisation.

---Above was Methodology---

Info regarding adding some other points in LR
In a dissertation literature review, the goal is not only to list works that exactly match your topic but also to cover:

Directly related work – visualisers specifically for divide and conquer algorithms.
Indirectly related work – general-purpose algorithm visualisers, visualization frameworks, or tools that could be applied to divide and conquer algorithms, even if the authors didn’t focus on them.
If you include those “plain visualiser” papers, you should:
Explain the connection – e.g.,
“While this tool was designed as a general-purpose algorithm visualiser, its architecture supports recursive execution tracing, making it applicable for visualising divide-and-conquer algorithms.”
Organise them in categories – maybe have a section in your literature review like:
Specialised Visualisers for Divide and Conquer Algorithms
General Algorithm Visualisation Frameworks with Potential Divide-and-Conquer Applications
Make the justification explicit – so the examiner sees you are deliberately including them, not just padding the count.
This is actually quite common in academic writing — a lot of strong dissertations draw on both specific and general works, showing the candidate understands the broader context.
If you want, I can suggest a structured template for integrating those 15 direct papers and the extra general ones into a coherent, academically defensible literature review section so it looks intentional, not forced.

---

Modified Lit Review with different subtitles

Background
There are certain types problems in the field of computer science that is too big to be solved directly. In such cases, it is more logical and easy to break them down into smaller chunks and solve them independently. The solutions of these smaller chunks can then be merged to obtain the solution of the main large problem. This approach of solving problems is called Divide-and-Conquer (D\&C) Algorithms. The core concept behind D\&C algorithms is recursion - the problems are broken down recursively until they are small enough to be solved directly which is known as base case. The algorithm then uses the base case solution(s) to solve larger chunks and merges them recursively until the main problem is solved. The diagram of algorithm execution is as shown in Figure x.

D\&C algirithm has various advantages mainly in terms of speed of execution. By breaking down the problems into more manageable chunks, it can reduce the overall time complexity of the solution compared to brute force method of solving problems. At times, it is designed to work efficiently in place requiring minimal additional memory apart from the input data. After the solutions are generated, it efficiently makes use of memory caches due to which solutions are processed swiftly. Moreover, the subproblems generated are independent of each other which means they can be solved concurrently on different cores or processors, leading to substantial speedup in execution. D\&C algorithms naturally transforms a complex problem into smaller, more manageable instances of the same problem. This reductionist approach is intellectually satisfying and leverages the solution to the fundamental subproblem repeatedly.

Literature Review

1. Divide and Conquer Visualisers

Sanhueza et al. [11] highlight their innovative work mQAPViz, an algorithm that employs a divide-and-conquer approach to handle large-scale data visualisations. This method is based on the Multi-Objective Quadratic Assignment Problem (mQAP) and uses advanced sampling techniques and efficient data structures to scale to millions of data objects. This approach specifically addresses the scalability limitations of existing methods, enabling visualisation of datasets orders of magnitude larger than previously feasible. The algorithm employs Pareto optimization to explore trade-offs between the two visualisation objectives without requiring predefined weights. They also conducted experiments that demonstrated mQAPViz's superior scalability and effectiveness on very large datasets compared to monolithic optimization approaches.

Velázquez-Iturbide et al. [12] present surveys on existing visualisations and propose three complementary, coordinated views: animation of the activation tree, animation of the data structure, and sequences of visualisations of substructures. These views aim to enhance the understanding of the recursive nature and data manipulations present in Divide and Conquer (D&C) algorithms. The key highlight of this work is that the system dynamically tracks execution traces to visualise recursion tree structures, subproblem decomposition, and intermediate solution merging in real-time for any given inputs. Implementation details demonstrate how visual mappings handle key divide-and-conquer stages (divide, conquer, combine) using indentation, nesting, and color coding. The design of visual mappings in this dissertation, particularly for representing hierarchical decomposition and recursive processes, draws inspiration from the rule-based approach for divide-and-conquer algorithms proposed by this work.

Behroozi et al. [13] propose an optimization model and five new algorithms for generating tree-maps, including two divide-and-conquer approaches and three spiral tree-map algorithms. These methods aim to improve the visual quality and computational efficiency of tree-maps, which are used to visualise hierarchical data. The D&C strategies contribute to more efficient and visually appealing tree-map layouts. This paper offer valuable insights into utilizing D&C strategies for creating effective and scalable data visualisations. Algorithms dynamically adjust partitioning directions (horizontal/vertical/radial) based on data properties and user-defined constraints. This dynamic approach to visualise the algorithms has inspired _me_ to have similar visual effects in this dissertation.

2. Visualisations in teaching field

Similarly, Hansen et al. [7] have observed in their studies related gamifying the teaching process of algorithms that educational games have shown to enhance learning outcomes, increase interest and keep the students hooked to the concepts. They also improve motivation to learn, and allow students to achieve various learning objectives. More importantly, this study identified critical features for educational effectiveness, such as depicting data structure evolution, supporting prediction, and offering multiple simultaneous views (conceptual vs. operational). However, the key thing to note from these studies is the fact that passive viewing of these algorithmic visualisations are helpful only upto a certain extent. For a high degree of effectiveness, these visualisations require careful integration with instructional activities and learner interaction.

A study by Battistella et al. [8] demonstrated how games designed to teach various sorting algorithms increased student engagement and friendly competition, making learning more enjoyable. They made a large scale evaluation involving more than 1000 students from different high schools and universities, comparing learning outcomes between groups using the game and traditional teaching methods. The results showed a significant improvement in the understanding of the underlying working principle of sorting by the group which used the game compared to traditional teaching methods. The findings provide strong empirical evidence supporting the effectiveness of well-designed educational games for teaching fundamental computer science concepts

The work by Su et al. [9] introduces DeCode, an educational tool that provides an interactive learning environment to help students gain confidence with Data Structures and Algorithms (DSA) concepts related to fundamental linear data structures like arrays, lists, stacks, and queues. The interesting thing about this work is its dual-layer design - visualisations demonstrate the working of various concepts while the game-mechanics contextualize operations within meaningful problem-solving scenarios. This requires users to apply the algorithms to solve various problems rather than just passive observation. However, the integration of real-time code visualisation synchronized with game states, would have offered an excellent dimension to their implementation details.

The work by Kostadinov et al. [14] introduces a specialized visual tool designed to help students interactively explore sorting algorithms and their computational complexity through real-time animation. A core innovation is the integrated complexity analysis module, which visually correlates runtime behavior with theoretical O(n) complexity classes during execution. The tool includes educational scaffolding like step explanations, pseudocode highlighting, and adjustable data sets (size, initial order). Evaluation with computer science students demonstrated improved understanding of time and space complexity concepts and algorithm behavior. This work exemplified how targeted visualisation tools can demystify abstract algorithmic concepts by linking theory to observable execution patterns.

3. Visualisations that conducted User studies

Hundhausen and Douglas [xa] proposed a system called ALVIS (ALgorithm VIsualiser Storyboarder) which mainly comprised of low fidelity visualisers built through domain specific scripting language called SALSA (Spatial Algorithmic Language for StoryboArding). This system emphasised sketch-style (akin to hand drawn) representation over polished graphics with the intention of reducing cognitive load on the minds of the learners. They hoped that it would foster better learning engagement. The visualisations were created by defining data states and their transitions using simple textual commands. They execute in an interactive player with various controls such as step through, speed adjustment, and annotation overlays. It promoted active learning by allowing students to modify the visualisations and predict the outcomes. The evaluation done by the authors showed that there were significant learning gains compared to high-fidelity tools which was a result of reduced extraneous cognitive processing.

Rößling and Naps [xb] proposed a testbed framework shifting focus from technical features to educational impact. This aimed to evaluate the pedagogical requirements for effective visualisations of algorithms.
They identified two core pedagogical criteria - interactivity and learner control - that are essential for actual knowledge transfer compared to passive animations. It demonstrated that visual clarity alone can sometimes be insufficient to make students comprehend the algorithms. The work bridges the gap between AV developers and educators by translating pedagogical theory into evidence-based design guidelines. The key insight that can be drawn from this work is that AVs must prioritize learner-centric animations over technological sophistications.

Shaffer et al. [10] performed a detailed analysis of over 500 algorithm visualisers available on the web until 2010 and systematically categorised them based on target audiences, diverse technical approaches and educational goals. They also identified the key factors necessary for the effectiveness of these visualisers such as engagement, integration to pedagogy, intuitiveness, etc. They concluded their analysis by noting that while algorithm visualisers significantly improve the learning experience, students should be aware of numerous low-quality visualisers alongside a few technically detailed and robust ones.

4. Technological Advancements in Visualisers

Visualisations are an excellent approach to address the challenges of understanding abstract theories [6]. They enable learners to break down complex information and algorithms into more manageable chunks, which results in better comprehension. The work by Brown & Sedgewick [6] introduced the earliest known comprehensive algorithm simulator/animator. It presented dynamic visualisations of algorithms in action with interactive controls (play, pause, step through, speed adjustment) allowing users to actively explore an algorithm's execution at their own pace. Following this influential approach, the visualiser developed as part of this dissertation implements core interactive controls for divide-and-conquer use cases — including divide, conquer, and solve functionalities — allowing users to dynamically navigate through the visualisation.

Carson et al. [xc] proposed Algorithm Explorer which visualises algorithms with immersive 3D multimedia environment with the goal of enhancing spatial understanding of various computational processed. They leveraged the 3D graphics library of C++ along with Visual Studio .NET to create immersive visualization experience for the learner. Users have the option to freely navigate through first person controls and receive dynamic viusal effects with synchronised auditory feedback to create multi sensory learning experience. It was mainly designed for complex algorithms such as graph traversals, geometric computations and the early evaluations suggested improved mental model formation for such abstract concepts. But it also proved to be challenging to novice learners due to increased cognitive load management.

The research by Karavirta et al. [xd] provides a very intersting model to build live visualisations for a wide range of algorithms including divide and conquer. This enables dynamic visualisations during lectures by parsing pseudocode annotations to generate real time animations. Moreover, this system integrates with presentation tools allowing lecturers to embed AVs without switching applications. While it is meant to address the time-consuming aspect of animation creation, it requires users to provide sufficient and accurate annotations to map the algorithm logic to its visualisation. The evaluation study performed by the authors suggested that there was a bit of learning curve for the educators to correctly add annotations but they reported improved student engagement during explanations due to live visualisations capabilities. This approach bridges the gap between pedagogical needs and practical constraints in lecture settings.

Vrachnos et al. [xe] proposed DAVE - Dynamic Algorithm Visualization Environment for Novice Learners - which is a dynamic algorithm visualiser that can animate not just the sample algorithms but also users' custom algotithms. The major improvement over all previous works is that it does not need users to learn any new scripting language or annotate their code with specific animation related codes. They created a custom java compiler with the help of ANother Tool for Language Recognition(ANTLR)[x] tool which maps the data objects identified in the users' code to their necessary visial counterpaarts in the visualisation. This is a great breakthrough in animation visualisation as users can create real time animation with nothing but the code of their algorithm. However, it works only with 2D animations of array algorithms such as searching and sorting. The authors have also mentioned the plans to add graph visualisation capabilities in the future.

take decisions and make them right.

be a bit assertive bro. enough is enough. learn some tips

think for longer good. do not prevent any. just make it inaccessible.
