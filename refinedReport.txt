Methodology (how you are going to achieve the objectives)

This section outlines the entire methodology used to develop interactive visualisations for three use-cases of divide and conquer algorithms: Quicksort, Convex Hull, and Binary Tree Construction. These visualizations were created with the goal of helping users get a deeper conceptual understanding of recursion and divide-and-conquer algorithms through an intuitive, step-by-step interface.

Quicksort
Methodology:
The user is given the liberty to input as many numbers as they wish. These numbers need to be entered either as comma-separated or space-separated values. Once done, they can either click the 'Insert' button present on the screen or press 'Enter/Return' key on the keyboard. Upon submission, grey rectangular bars are rendered on the screen at the center. The height of each bar corresponds to the value of the respective number entered. These bars are rendered in the same order in which the user entered those numbers.

Once the user has provided the desired numbers to sort, two options are available—'Divide' and 'Solve'. At this point, the 'Conquer' button remains disabled as it is not possible to perform the conquer step before any divide is performed. If the user clicks 'Solve', the original grey bars are shifted to the left half of the screen and the final sorted array is displayed instantly on the right half of the screen without any intermediate steps. On the other hand, if the user clicks 'Divide', it initiates the divide-and-conquer process. This makes the algorithm select a pivot element using the 'Median of 3' strategy. This involves selecting the first, middle, and last elements of the array, sorting them in ascending order and choosing the median value as the pivot. Some other common strategies to choose the pivot element are picking the first element of the array, the last element of the array etc. However those methods result in the sorting algorithm degrading to the worst case time complexity of O(n^2) in case the provided array is already sorted or fully reverse sorted. By opting for 'Median of 3' strategy, it is more likely to select a pivot closer to the true median, which results in a more balanced partitions and maintains O(nlogn) average-case efficiency.

The next step after selecting the pivot element is to rearrange the array so that all elements smaller than the pivot are placed to its left and all larger elements are placed to its right. After the rearrangement, a new set of rectangular bars is drawn below the original input bars. The pivot is highlighted with a different colour and is placed with a wider gap from all other elements. The colour of each pivot bar is based on the depth/level in which it was picked. Each time the user clicks on 'Divide' the variable 'level' is increased to keep track of pivots as mentioned above. These levels represent how deep the partitions have gone— 'level 0' being the first time the user clicks 'Divide', 'level 1' the next, and so on. The colour codes of bars are such that pivot chosen in level 0 is represented in red, in level 1 is blue, in level 2 is green, level 3 is orange, level 4 is brown, level 5 s violet, and lastly level 6 - greenyellow. (Think of adding how you will manage more level colours...remember the bug?)

As the new set of bars is rendered, two partitions become clearly visible, with the pivot element separating them. When the user clicks 'Divide' again (i.e., level 1), each partition is treated as a subarray, and the same pivot-selection and rearrangement process is applied to each subarray. Each time this happens, new rows of rectangular bars are drawn below the previous row of bars. The pivots in each of these rows are highlighted with different colours (as shown in image). After each partitioning, the algorithm checks if it is possible to partition the array further. It is possible if there is at least one subarray that has two or more elements. If not, it implies that every element is either chosen as a pivot or is alone in its own subarray. At this point, the 'Divide' button is disabled and only the 'Solve' button remains enabled.

Clicking the 'Solve' button at any stage after clicking on 'Divide' at least once generates the intermediate solution based on the partitions created until that point. If clicked after all divide steps are completed, it takes the process to the conquer stage and displays the sorted array on the right side of the last row of bars created. Since the array is already sorte when the divide phase is completed, clicking 'Solve' here performs no additional computation. However, in this case, the 'Solve' button becomes disabled and the 'Conquer' button is enabled instead.

This behavior, where the array is already sorted at the end of the divide phase, is intentional. It helps show how the divide-and-conquer strategy works. To clarify this, during the divide phase, pivot elements have unique colors and spacing to mark the partition boundaries clearly as mentioned previously. In the conquer phase, these pivot bars are reverted to their default grey colour, and their spacing is reduced to blend them back into the final sorted array. Each time the user clicks 'Conquer' button, the pivots selected in the corresponding divide step are merged back into the array. As the user continues clicking 'Conquer', the pivots are visually removed one by one, and by the final conquer step, the fully sorted array is shown as a single row of grey bars, signifying the completion of the sorting process.

To help the user track their interactions and keep themselves informed of what has happened in the visualiser, toast messages and logs option is included in the visualiser. The toast message displays the actions performed by the user along with the corresponding computational steps performed by the system. It is also colour coded for different types of messages-red for error messages, green for success messages and light grey for normal informations. These messages are programmed to stay on the screen for 10 seconds and disappear. Once it leaves the screen, it will be displayed in the logs panel. The logs panel can be accessed anytime by clicking on 'Logs' button. To illustrate the functioning, when the user clicks divide, it shows which element was chosen as a pivot and what the three elements were whose median was used to select the pivot. When the user enters or deletes the numbers initially logs insertions or deletions from the input array. It also indicates when the divide phase completes and, during the conquer phase, it logs the merging of partitions and the final successful sorting step. Whenever a new toast message needs to be displayed, it replaces the existing toast message. However, the old message can still be viewed through the logs panel.

As this tool can be used by students who do not have a full working knowledge of quicksort, it includes an FAQs section. This section explains what quicksort is, how the pivot is chosen and how divide and conquer algorithm is applied to perform sorting. It also answers many questions that users may have regarding the interface such as the meaning of the different coloured bars, disabling of buttons based on the execution timeline and also describes the functionalities of various interface components like buttons and logs.

Additionally, a 'Guide Me!' button is available to assist users interactively. Clicking this button displays tooltips explaining the functions of each interactive component on the screen. Each tooltip consists of the explaination text along with '->', '<-' and 'x' used to go to next, previous tip and to close the tips totally. Users can navigate these tips at their own pace. These tips can be invoked at any point during execution, ensuring users can understand the purpose and effect of each button whenever needed.
