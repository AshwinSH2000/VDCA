Methodology (how you are going to achieve the objectives)

This section outlines the entire methodology used to develop interactive visualisations for three use-cases of divide and conquer algorithms: Quicksort, Convex Hull, and Binary Tree Construction. These visualizations were created with the goal of helping users get a deeper conceptual understanding of recursion and divide-and-conquer algorithms through an intuitive, step-by-step interface.

Quicksort
Methodology:
The user is given the liberty to input as many numbers as they wish. These numbers need to be entered either as comma-separated or space-separated values. Once done, they can either click the 'Insert' button present on the screen or press 'Enter/Return' key on the keyboard. Upon submission, grey rectangular bars are rendered on the screen at the center. The height of each bar corresponds to the value of the respective number entered. These bars are rendered in the same order in which the user entered those numbers.

Once the user has provided the desired numbers to sort, two options are available—'Divide' and 'Solve'. At this point, the 'Conquer' button remains disabled as it is not possible to perform the conquer step before any divide is performed. If the user clicks 'Solve', the original grey bars are shifted to the left half of the screen and the final sorted array is displayed instantly on the right half of the screen without any intermediate steps. On the other hand, if the user clicks 'Divide', it initiates the divide-and-conquer process. This makes the algorithm select a pivot element using the 'Median of 3' strategy. This involves selecting the first, middle, and last elements of the array, sorting them in ascending order and choosing the median value as the pivot. Some other common strategies to choose the pivot element are picking the first element of the array, the last element of the array etc. However those methods result in the sorting algorithm degrading to the worst case time complexity of O(n^2) in case the provided array is already sorted or fully reverse sorted. By opting for 'Median of 3' strategy, it is more likely to select a pivot closer to the true median, which results in a more balanced partitions and maintains O(nlogn) average-case efficiency.

The next step after selecting the pivot element is to rearrange the array so that all elements smaller than the pivot are placed to its left and all larger elements are placed to its right. After the rearrangement, a new set of rectangular bars is drawn below the original input bars. The pivot is highlighted with a different colour and is placed with a wider gap from all other elements. The colour of each pivot bar is based on the depth/level in which it was picked. Each time the user clicks on 'Divide' the variable 'level' is increased to keep track of pivots as mentioned above. These levels represent how deep the partitions have gone— 'level 0' being the first time the user clicks 'Divide', 'level 1' the next, and so on. The colour codes of bars are such that pivot chosen in level 0 is represented in red, in level 1 is blue, in level 2 is green, level 3 is orange, level 4 is brown, level 5 s violet, and lastly level 6 - greenyellow. (Think of adding how you will manage more level colours...remember the bug?)

As the new set of bars is rendered, two partitions become clearly visible, with the pivot element separating them. When the user clicks 'Divide' again (i.e., level 1), each partition is treated as a subarray, and the same pivot-selection and rearrangement process is applied to each subarray. Each time this happens, new rows of rectangular bars are drawn below the previous row of bars. The pivots in each of these rows are highlighted with different colours (as shown in image). After each partitioning, the algorithm checks if it is possible to partition the array further. It is possible if there is at least one subarray that has two or more elements. If not, it implies that every element is either chosen as a pivot or is alone in its own subarray. At this point, the 'Divide' button is disabled and only the 'Solve' button remains enabled.

Clicking the 'Solve' button at any stage after clicking on 'Divide' at least once generates the intermediate solution based on the partitions created until that point. If clicked after all divide steps are completed, it takes the process to the conquer stage and displays the sorted array on the right side of the last row of bars created. Since the array is already sorte when the divide phase is completed, clicking 'Solve' here performs no additional computation. However, in this case, the 'Solve' button becomes disabled and the 'Conquer' button is enabled instead.

This behavior, where the array is already sorted at the end of the divide phase, is intentional. It helps show how the divide-and-conquer strategy works. To clarify this, during the divide phase, pivot elements have unique colors and spacing to mark the partition boundaries clearly as mentioned previously. In the conquer phase, these pivot bars are reverted to their default grey colour, and their spacing is reduced to blend them back into the final sorted array. Each time the user clicks 'Conquer' button, the pivots selected in the corresponding divide step are merged back into the array. As the user continues clicking 'Conquer', the pivots are visually removed one by one, and by the final conquer step, the fully sorted array is shown as a single row of grey bars, signifying the completion of the sorting process.

To help the user track their interactions and keep themselves informed of what has happened in the visualiser, toast messages and logs option is included in the visualiser. The toast message displays the actions performed by the user along with the corresponding computational steps performed by the system. It is also colour coded for different types of messages-red for error messages, green for success messages and light grey for normal informations. These messages are programmed to stay on the screen for 10 seconds and disappear. Once it leaves the screen, it will be displayed in the logs panel. The logs panel can be accessed anytime by clicking on 'Logs' button. To illustrate the functioning, when the user clicks divide, it shows which element was chosen as a pivot and what the three elements were whose median was used to select the pivot. When the user enters or deletes the numbers initially logs insertions or deletions from the input array. It also indicates when the divide phase completes and, during the conquer phase, it logs the merging of partitions and the final successful sorting step. Whenever a new toast message needs to be displayed, it replaces the existing toast message. However, the old message can still be viewed through the logs panel.

As this tool can be used by students who do not have a full working knowledge of quicksort, it includes an FAQs section. This section explains what quicksort is, how the pivot is chosen and how divide and conquer algorithm is applied to perform sorting. It also answers many questions that users may have regarding the interface such as the meaning of the different coloured bars, disabling of buttons based on the execution timeline and also describes the functionalities of various interface components like buttons and logs.

Additionally, a 'Guide Me!' button is available to assist users interactively. Clicking this button displays tooltips explaining the functions of each interactive component on the screen. Each tooltip consists of the explaination text along with '->', '<-' and 'x' used to go to next, previous tip and to close the tips totally. Users can navigate these tips at their own pace. These tips can be invoked at any point during execution, ensuring users can understand the purpose and effect of each button whenever needed.

---

For any given point or set of points, the convex hull is the smallest set of points such that drawing a boundary around them encloses all the points, forming a convex polygon. A convex polygon is one where all interior angles are less than 180 degrees, meaning that all vertices point outward and no angle “caves in.” While humans can easily identify the convex hull visually, it is not straightforward for a computer to do the same. To determine the convex hull computationally, the algorithm applies the divide and conquer technique recursively.

The overall idea is to divide the set of points into smaller partitions using perfect vertical lines until each partition contains only one or two points. In the special case of exactly vertical collinear points, the partitions may contain more than two points, as dividing them further using vertical lines is not possible. The base cases for convex hulls are either a single point or a line segment connecting two points. In the special collinear case, the base case consists of the line joining all the vertical collinear points.

The execution begins with the user clicking on the intersections of the grid. The grid's dimension is 11x11 and the user can click on any of the 121 points available. If the click is near the intersection, then the point is registered and a toast message gets displayed mentioning the same. However, if the user clicks further away from the intersection, the an error toast message is displayed which asks the user to click closer to the intersection. The user has the freedom to select any number of points to draw the convex hull. Once all the points are clicked, they again have two optopns initially - Divide and Solve. Clicking on solve immediately displays the convex hull for the entered points without displaying any intermediate steps.

To begin the partitioning, the algorithm filters the set of points based on their sorted, unique x-coordinates (sortedUniqueXCoords). The y-coordinates are not yet considered at this stage. For instance, consider the points [5,2], [7,1], [7,2], [7,3], [9,1], [9,2], and [9,3] to be in the coordinates array. There are multiple points having the same x-coordinates but different y-coordinate, meaning they are collinear. Therefore, the sortedUniqueXCoords of this set of points would be [5, 7, 9], representing projections of the points onto the x-axis. The partitioning is then done by splitting sortedUniqueXCoords. If there are even number of elements, both the partitions will consist of equal number of elements after splitting; if odd, the right partition receives one more element than the left. In this case, x = 5 would be in the left partition, while x = 7 and x = 9 would fall in the right partition. The important thing to note is that, while splitting, the actual coordinates array is not considered.

Similar to how the pivot elements are colour coded in quicksort, the partitioning lines are color-coded according to the level at which the division occurs. The 'level' variable is incremented each time the user clicks on 'Divide' button. Red colour is used to draw the partition line generated in level 0, blue for level 1, yellow for level 2, and cyan for level 3. Since the grid size is 11x11, there are 121 points the user can click on. Only one partition is possible in level 0, up to a maximum of two new partitions in level 1, up to four in level 2, and up to eight in level 3. However, given the space constraints, only three more new partitions can be added at level 3, despite its theoretical capacity of eight.

If additional divides are possible, the process continues. In the previous example, the new sorted x-coordinates for the right side become [7, 9], since x = 5 has already reached its base case. A blue dotted line is drawn between 7 and 9. Since these points are vertically collinear, further division is not possible, and the divide phase concludes. However, for other examples, if further division is possible, partition lines will continue to appear, colored based on their respective divide level. Once all possible divide operations are complete, the "Divide" button is disabled.

At this point, only the "Solve" button remains enabled. Clicking it displays the base case convex hulls for each partition—lines for partitions containing two points and single points for singleton partitions. After this step, the "Solve" button is disabled and the "Conquer" button becomes active. Clicking "Conquer" triggers the merging of convex hulls in reverse order of their creation. As each merge is performed, the resulting hull grows in size. The in-focus partition lines and hulls are displayed with solid, brightly colored lines, while out-of-focus elements are shown using dull, dotted lines. During each conquer step, the convex hulls across partition lines are joined, and their colors update to match the previous divide level. This process continues until the final convex hull is drawn in green.

The merging of convex hulls at each conquer step follows a specific algorithm. Given two sets of points to merge, the algorithm selects the rightmost point from the left set (say pt1) and the leftmost point from the right set (say pt2). With pt1 and pt2 fixed, it iterates over all points in the right set to find the topmost point such that the lines joining pt1, pt2, and a new point turns towards the top direction. Existence of such a point indicates that there is another point that is above pt2. When such a point is found, it is updated as pt2, and the process continues until there is no change in pt2. When this loop finally breaks, topmost point in the right set is identified as pt2. The same process is repeated on the left set to search and update pt1. This results in pt1 and pt2 marking the end points of top tangent between the two sets and no points lie above this line. A common doubt that generally comes to people is why we need to do such a lengthy process to find the top tangent. Why cant we just findout and choose the topmost point in each of the set of points? The answer lies in the fact that sometimes, the line drawn through the topmost point of a set might not lie above all the points in both the sets as shown in the figure x.

The algorithm then executes a similar loop to find the bottom tangent. This time, it looks for points that make the lines turn towards the bottom—essentially the inverse of the process for the top tangent. Once both tangents are found, the end points define the corners of a quadrilateral. The algorithm then checks all other points to determine if they lie within this polygon. If a point is inside or on the edge, it is ignored. If it lies outside, it becomes part of the final convex hull edge. The original coordinates array is then updated with the new hull points, and this process repeats with each conquer operation until only one set remains.

In some cases, the top and bottom tangent points in one or both of the hulls may be the same, reducing the quadrilateral to a triangle or simply a line. However, the algorithm still functions exactly as stated above. Such cases can arise if all the points in one or both the sets are horizontally collinear.

The "Solve" button allows users to reach the solution quickly. If used before any divide operation, it computes and displays the convex hull of all the points instantly without visualising any of the intermediate steps. If used after completing all divide operations, it reveals the base case solutions. When used at any intermediate stage, it displays convex hulls for the partitions already created. The user cannot skip the "Solve" step; after all divide operations are completed, it is the only available button and must be clicked to proceed.

Similar to the quicksort visualizer, this tool includes a logging feature. Every time a user clicks on a point, a message is logged to indicate that the point was added to the array. Clicking on the same point again removes it and logs a delete message. If a user clicks somewhere not aligned with the grid, an error message is displayed, asking the user to click closer to the intersection of the grid lines. During the divide phase, logs indicate the x-coordinates where partitioning occurred, and during the conquer phase, the x-coordinates of the merged partitions. Success messages are also shown when the divide or conquer phases are completed.

The visualizer also includes an FAQ page to help users understand what convex hulls are and how the divide and conquer algorithm is implemented in this tool. Additionally, there is a "Guide Me!" button that activates tooltips explaining the functionality of each button in the interface. Users can navigate through these tips using left and right arrows or close them using the "x" button. Tooltips also close automatically upon reaching the final tip. These guides can be accessed at any point during execution to assist users in understanding the interface. Lastly, a "Reset" button is provided to reset the entire interface. Buttons within the visualizer are dynamically enabled or disabled based on the current state of the algorithm.
