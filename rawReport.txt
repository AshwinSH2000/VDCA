Section x - Methodology / Implemented work

1. Quicksort

How is it implemented?
i. Accepting input
ii. Repeated clicking on divide and conquer along with/or once click on solve until final result is achieved. 

The user is given the liberty to input the numbers. 
They can input as many numbers as needed and click 'Insert' button or press 'Enter/Return'. 
The numbers can either be comma separated or space separated. 
On entering the numbers, grey rectangular bars are displayed on the screen whose height is equal to the value of the numbers. 
Once the user has entered all the numbers, they have two options - 'Divide' or 'Solve' (Conquer button is still disabled at this point). 
Clicking on 'Solve' will instantly display the final sorted array. 
However, if the user clicks on 'Divide', then the algorithm initially picks a pivot element using the 'Median of 3' approach. 
In this approach, the first, middle and the last element are placed in the sorted order and the median element is chosen. 
This becomes the pivot element to sort the array. The numbers of the arrays are then rearranged in such a way that all the numbers that are smaller than the pivot are placed on the left side of pivot and all numbers larger than the pivot are placed on the right side of pivot. 
After this, another set of bars are drawn based on the new arrangement of numbers but the pivot element is shaded with a different colour and placed with a slighly larger gap from all other elements. 
The colour of the pivot elements are based on the level of partition (level 0 - red, level 1 - blue, level 2 - green, level 3 - orange, level 4 - brown, level 5 - violet, level 6 - greenyellow). Level simply means how deep the partitions are made. 
For example, when the user clicks 'Divide' for the first time, it is called level 0, next click of 'Divide' is called level 1 and so on. 
Once a new set of bars are displayed below the original input bars, one can clearly see there are two groups of numbers separated by the pivot element. When the user clicks on 'Divide' again (level 1), each of these partitions is treated as a whole array and the same process is repeated, where a pivot is chosen, the numbers are rearranged, and new row of rectangular bars are drawn with all the pivots highlighted. 
Partitioning is possible as long as there is at least one subarray which has two or more elements in it. 
Partitioning stops when all the elements are chosen as pivot elements or there is just one element in each new partition. 
At this point the 'Divide' button is disabled and only 'Solve' button would still be enabled.

Clicking 'Solve' button at any point generates the solution from the partitions alreadt created. If it is clicked before 'Divide', then the web-app displays the final sorted array directly as there were no partitions created. When it is clicked after all the divide operations, then as the array was already sorted, it displays the same rectangular bars on the right hand side of the screen. As the array was already sorted, the solve button does nothing special here. At this point, the 'Solve' button is disabled and 'Conquer' button gets enabled. This is a but peculiar case, as when the last step of divide is reached, then the solution is actually obtained. But inorder to show how divide and conquer is applied, we separate the pivot elements with more space and a different colour in the divide phase and then revert them to grey colour and reduce the space at different levels in the conquer phase. When the user clicks on 'Conquer' the pivots selected in the corresponding divide step will be changed back to grey level and their gap will be reduced and the whole array is shown once again. So as the user clicks on 'Conquer' further, the pivots are removed one by one and at the last conquer step, the array will be shown in the fully sorted order with all grey bars meaning all the pivots are removed and that solution is perfectly sorted. 

To let the user know what happened at each step, there is a logs functionality. It displays the action that the user took and also shows the computational result that the computer perfoemed such as displaying which element was chosen as the pivot, what were the three numbers whose median turned out to be the pivot element. It also lists the insertion and deletion of numbers into the arrayin the logs so that the user is informed what action was performed. Then it also informs the user at what time the divide phase is complete. During the conquer phase, it lets the user know theough logs the partitions across which pivots were merged and also informs the user of the final conquer step where the array is successfully sorted. 

Not all users may be very well versed with quicksort. Hence to familiarise the users with quicksort and other functionalities of the web-app, there is an FAQs section as well. Clicking it gived the users informtion about quicksort, how the pivot os chosen in this case, how exactly is divide and conquer applied here and so on. It also explains about the different coloured bars and a few functionalities of the site such as different buttons, logs etc. Apart from that, there is also a 'Guide Me!' section which starts displaying the tooltips for the users regarding different buttons present on screen. They can navigate the tips in their own pace by using the left and right arrow depicting previous and next tups respectively. There is also a x button to close the tips fully. The tips also get closed when the user clicks on right arrow on the last tip. These tips can be invoked at any point in the execution of the program as it is important for the user to know what each button does to understand the tool fully. 

2. Convex hull

For any given point(s), its convex hull is the smallest set of points such that drawing a boundary around them encloses all the points forming a convex polygon. A convex polygon is a polygon where all interior angles are less than 180 degrees. This means all vertices point outwards and no interior angle “caves in”. Visually for humans, they can quickly identify the convex hull for any given set of points but it is not the case with the computer. To identify the convex hull, it recursively applies divide and conquer algorithms. The overall idea is that, the algo divides the set of points into smaller and smaller partitions using only perfect vertical lines until there are either one or two points in each partitions. In a special case of exactly vertical collinear points the partitions are allowed to have more then two points because it is not possible to divide them using a perfect vertical line. The base case convex hulls are either just a point or the line joining two points. In the special case mentioned above, the base case is the line joining all the vertical collinear points. 

So how are the partitions divided? So the algorithm takes all the points and then filters the sorted non repetitive x-coordinates. This is becasue the algorithm does not bother about the y-corrdinate of the points as yet. For example, we have points [5,2], [7,1], [7,2], [7,3], [9,1], [9,2] and [9,3]. What the algorithm initially does is that it seens the points having 7 as its x coordinates are all collinear and the points having 9 as its x coordinates are all collinear. Hence in its list of sorted non repetitive-x coordinates, it will only contain [5, 7, 9] because the points when projected on to the x axis consist of only these points. Then it creates a partition such that these non repetitive x-coordinates are split into two. If there are even elements, then the partitioning is exactly half and in case there are odd number of elements, then the partition on the right contains one more element  than on the left. In the case of our example, the splitting is done such that point with x-coordinate 5 will be on the left side of the partition line and points with 7 and 9 as their x coordinates will be on the right side of the partition lines. The partitioning lines are colour coded (red = level 0, blue = level 1, yellow = level 2 and cyan = level 3) and a red coloured dotted line will be drawn in beterrn 5 and 7 to highlight the partitioning line. If no more divide operations are possible, then the divide button gets disabled. However in this chosen example, one more divide is possible. The sorted non repetitive x coordinates is now [7, 9] because 5 is already just a point in the partition which means it has reached its base case. The splitting of [7, 9] happens by a vertical blue coloured dotted line drawn between those two numbers. Since all the points in 7 and 9 are collinear, we cannot divide any further and the divide phase ic complete. But if the divide could be still continued for some other examples, dotted partition lines will be drawn based on the level in which the division is happening. 

At this point the base case is reached and only the 'Solve' button will be enabled. Upon clicking the solve button, all the base case partitions are drawn. These include lines if the partition contains two points, or just a point if the partition contains only one point. At this point, even the solve button gets disabled and the conquer button gets enabled. Now, when the user clicks the conquer button, then all the convex hulls are merged in the reverse order in which they were created, and the hulls become bigger after each conquer operation. The in-focus partition lines and the base cases hulls will be brightly coloured and solid lines while the out-of-focus partition lines and hulls will be dull and dotted lines. At each conquer phase, the hulls drawn across each partition lines will be joined and its colour will be changed to the colour of the previous level. This repeatedly goes on until the final hull is drawn in green colour. 

As the grid is 11x11, there are 121 points the user can click on. Based on that, in level 0, there can be 1 partition. in level 1 ,there can be a maximum of two partitions. in level 2 there can be a maximum of 4 partitions and finally in level 3, there can be a maximum of 8 partitions but since we are having only 10 spaces to create partitions, in the last level there can be only 3 more (despite it can have 8 technically). 

How are the hulls merged and what is the algorithm used for that?
At each merge phase, there will be two sets of points. The algorithm then selects the rightmost point in the left set (lets call this point pt1) and the leftmost point in the right set (lets call this pt2). Then it keeps pt1 and pt2 fixed and iterates through all the points in the right set to check if there is any point such that the line joining pt1, pt2 and new point x takes a left turn as shown in the figure. If the line takes a left turn, then pt2 will be the new point and it iterates through all the points of the second set again. The goal of this is to find the topmost point in the righthand side set of points. Once it iterates theough all the points in the right set and comes out of the loop, pt2 will have the topmost point of the set. Now keeping pt1 and pt2 fixed, it iterates through all the points in the left set. If the line joining pt2, pt1 and the new point takes a right turn, then the new point will be updated as pt1 and the process is repeated for all the points in the left set. The loop is broken when there is no change in pt1 after scanning the entire left set of points. At this point pt1 will have the topmost point in the left set. pt1 and pt2 not represent the top tangent of the two convex hulls meaning the line pasing through these two points will not have any points above them. 
Now the same structure of the loop is repeated but this time, in the right set, the new point will be updated as pt2 if the line joining pt1, pt2 and the new point takes a right turn(opposite of what we did to find the top tangent point in the right set). In the left set, the new point gets updated as pt1 when the line joining pt1, pt2 and new point take a left turn(again, its the opposite of what we did to find the top tangent in the left set). After finishing this loop, pt1 and pt2 will be the vertices of bottom tangents of the twosets of points. This means all the vertices are now present above this bottom tangent and below the top tangent. We have found the top and bottom tangents but now need to check if we have any points to the left and right of these end points. These 4 points now form a quadrilateral. Next we iterate through all the points to check if they are inside the quadrilateral or not. While chekcing if we find that they are completely inside the polygon or even on the edges of the polygon, then we can safely ignore it as they will be enclosed by the polygon lines. If any point is strictly outside the polygon, then that point will be a part of the convex hull's edge. We replace the left and right hull set points in the original coordinates-array with the points forming the hull. The same process is repeated upon every click of conquer until there is just one set of points presenrt in the coordinates array. 
Sometimes, when joining two hulls, it can happen that instead of having 4 points, we end up with only 3 points end points. In such a case, instead of forming a quadrilateral, we form a triangle. The upper and lower tangent points for one of the set of points end up being the same as shown in the figure x. But the process can be continues as is. If the top and bottom tangents converge to a single point, it means that there is no other point above or below it. There also wont exist a point to the left of it (if this point is in the left set) or on the right (if this point belongs to the right set). 

What exactly does the solve button do?
The solve button is used to reach the solution quickly. If it is used even before clicking on 'Divide' then it displays the hull of all the points right away. If it is used after the divide button has been disabled after all possible divide operation, then it displays the base case solution. However, if it is used in any other intermediate situation, then it displays the solution of the partitions already created until that point. The user cannot escape using the solve button at all. In case they defy using it, then the only button that will be enabled after performing all divide operations is the solve button and in this case, it displays the base case solutions. 

Just like in the quicksort, there is logs functionality here as well. Each time a user clicks on a coordinate to enter it, a log message gets displayed to inform the user that the point is added to the array. Similarly, when the user clicks on the same point again, then it gets deleted and a corresponding delete message gets displayed. However, if the user clicks anywhere other than the actual points, then a error message gets displayed to let the user know that the point is not registered and asks the user to click closer to the intersection of the lines. At each divide phase, it displays the x coordinate in which the divide happens and similarly it displays the x coordinate across which the partitions were merged. It also displays the success messages when the division phase is completed and the merge phase is also completed. 

This also has the FAQs page to tell the users more about convex hulls and how divide and conquer algorithm is applied here. Also there is a 'Guide Me!' button using which the users can know what exactly is the functionality of different buttons present in the visualiser. And a reset button to reset the entire interface. In the visualiser interface, sime buttons get enabled and disabled according to the situation. 

3. Binary Tree construction

A binary tree can be uniquely constructed from its inorder and preorder traversals. The key is to recursively use preorder traversal to identify the root and then use the inorder traversal to split the nodes into left and right subtrees. Inorder traversal is the representation of the tree traversal in the order left child, followed by the root and lastly the right child. If the left and/or right child has further child node(s) then the same representation style is followed for them too. For example, the tree represented in Fig x has a inorder traversal as 4 2 5 1 6 3 7. Preorder traversal is the representation of the tree traversal in the order root, followed by the left child and lastly the right child. Similar to inorder traversal, if the left and right nodes have further child node(s), then this representation style is applied to them as well. For the same tree represented in figure x, the preorder tree representation is 1 2 4 5 3 6 7. Given these inputs, a unique tree can be constructed. 

How is the tree constructed from these inputs?
The first thing that the algorithm does is to validate the input provided by the user to check if an actual tree can be constructed by the provided traversals. If a tree cannot be constructed from it, then it immediarely displays a toast message saying the same. If it can be constructed, then it proceedes futther in the algorithm. 
The first element of the preorder traversal is always the root of the binary tree and lets call it x. This element x is then located in the inorder traversal and all the elements to its left form the left subtree and all the elements to its right form the right subtree. Now we have got two sub-inorder-traversals partitioned by the root in the main inorder-traversal. The elements present in each of these sub-inorder-traversals appear together in the preorder traversal as shown in the figure although not necessarily in the same order. The first element in each of these partitions in the preorder traversals is the root of that subtree. Similarly this root element is then located in the sub-inorder-traversal and it becomes the partitioning element creating two new sub-inorder traversals. These subtrees are then recursively divided by identifying the root of each subtree from their preorder sequence. This process goes in until there is only 1 element in each of the partition created which signifies that these elements are the leaf nodes of the tree. The tree is then constructed in the reverse order starting from the leaf nodes and attaching it to their parent nodes in each new level until we attach the main root to the two disjoint subtrees. Whtn the user clicks on 'divide' each time, then the algoritm takes the existing partitions and then splits them based on the root identified in that level. This process goes on until no more divisions are possible. Once all divide operations are done, only 'solve' button is enabled and clicking on that generates the leaf node(s). Now the solve button is also disabled and only conquer button is present. When the user clicks on 'conquer' button, it generates the preceding level of the tree and displays it. 

How are the trees drawn?
There is a class defined just to create and store the tree representation. It consists of three data namely left, right and value. Value field is used to store the integer value represented in that node while left and right contains the actual left and right nodes of that root node. In the divide phase, whwnwver a new node is found, a class object is created with the value being the same number and left and rigght data being null by default. And this node is attached to the left or right of its parent node depending upon from which side it was found. So when the tree reached the leaf node,the entire tree would have been constructed in this class data structure. (technically when we do the 'divide' operation in this visualiser, we are actually dividing then array and immediately conquering it. but to show it in the visualiser, we have a separate button for conquer and to show it visually, we construct the tree in the conquer phase...just the visual construction as the actual tree was already done constructing in the divide phase.)
In the divide phase, i make use of a special flag variable for each traversal element. If that element is identified as a root at any level , then i make its flag to be equal to true and also note down the level in which this element was identified as the root. When these numbers need to be displayed, then these two variables are checked. There are three cases here. 
1. If the flag variable is false, then it means that number hasnt been identified as the root in any level yet. Hence display that number as is in black colour. 
2. If the flag variable is true and the level in which it was found is the same as the current level, then display this number as is in the traversal but with a different colour. 
3. If the flag variable is true but the level in which it was found is not the same as the current level, then it need not be dosplayed and instead a blank space is inserted in its position to indicate the partitioning space as shwon in this image.

How are the nodes constructed in the conquer phase?
During the divide phase, we increase the level counter as each time the user clicks the divide button. However, in the conquer phase, the level counter is started from its max value that it reached in the divide phase and is decremented each time the user clicks conquer operation. At each level, the algorithm scans all the nodes created and draws the nodes and puts a circle around them in the same order in which these numbers are represented in the inorder tracersal. For example, the inorder traversal of the tree in figure x is 4 2 5 1 6 3 7 and out of these only nodes 4, 5, 6, and 7 are the actual leaf nodes. So in the first conquer phase, it only draws these numbers in the exact otder in which it is found in the inorder which in this case will be 4, 5, 6, and 7. There are other numbers whoch are already found at this point but they are not drawn here because their level value will be having a different number than the current level info. In the immediate next step, a function is invoked to check if any arrows need to be drawn. If yes, then this function identifies what are the parent nodes and what are their child nodes and draws lines between them. How it does? So the entire righthand side of the screen is divided into a large html div element. On that, there are so many smaller divs overlaid. The circular nodes are drawn on these smaller divs based on the level in which they are found. If a line needs to be drawn from parent node(s) to their child node(s) then this function gets the necessary coordinates the local smaller divs and then translates it into the larger div. Then draws the line. There is also an update function that is called after it is drawn to redraw these lines if the nodes move because of any reasons or when the new row of nodes are attached to the tree. 

------------------------------

Pending sections
1. Introduction
2. Lit Review
3. methodology
4. results
5. conclusion


LITERATURE Review

\subsection{Background}
D\&C algorithm is a problem solving technique used to solve problems by dividing the main problem into sub-problems, solving them recursively individually and then merging them to find solution to the original problem. The diagram of algorithm execution is as shown in \cref{DandC}.

There are various advantages of using D\&C algorithms. Some of them include faster processing due to efficient use of memory caches, faster processing of solutions due to parallel execution, and a better approach to common problems such as sorting.

\begin{figure}[h!]
\centering
\includegraphics[alt={a figure showing the overall conceptual diagram of divide and conquer algorithm},width=0.6\textwidth]{DandC2}
\caption{Conceptual diagram D\&C algorithm}
\label{DandC}
\end{figure}

\subsection{Related Work}

Visualisations are a great method for addressing the challenges of understanding conceptual theories \cite{2_brown1984system}. They help the learner to break down complex information into more digestible formats, making it easier for them to understand. 
Similarly, it has been observed by Hansen et al. \cite{4_hansen2002designing} that educational games have shown to improve learning outcomes, interest and motivation while allowing students to achieve a range of learning objectives. 

A paper by Battistella et al. \cite{6_battistella2017design} showed how the games introduced to teach quick-sort and heap-sort increased student activity, friendly competition and resulted in making learning more fun. The work by Su et al. \cite{1_su2021game} presents an educational tool called DeCode that offers an interactive learning environment to assist students acquire confidence with DSA concepts relating to fundamental linear data structures such as arrays, lists, stacks, and queues. Shaffer et al. \cite{5_shaffer2010algorithm} mentions that while algorithm visualizers do a great job in improving the learning experience, students must be wary of several low-quality visualisers that are present alongside a few technically detailed and robust ones. \\

The mQAPViz, an algorithm that employs a divide-and-conquer approach to handle large-scale data visualizations is the main highlight of the paper by Sanhueza et al. \cite{7_sanhueza2018mqapviz}. The method utilises the Multi-Objective Quadratic Assignment Problem (mQAP) as its foundation, applying advanced sampling techniques and efficient data structures to scale to millions of data objects. The paper by Vel{\'a}zquez-Iturbide et al. \cite{8_velazquez2009design} presents surveys on existing visualizations and proposes three complementary, coordinated views: animation of the activation tree, animation of the data structure, and sequences of visualizations of substructures. These views aim to improve understanding of the recursive nature and data manipulations present in D\&C algorithms. \\

Behroozi et al. \cite{9_behroozi2023space} presents an optimisation model and five new algorithms for generating tree-maps, including two divide-and-conquer approaches and three spiral tree-map algorithms. The proposed methods aim to improve the visual quality and computational efficiency of tree-maps, which are used to visualize hierarchical data. The D\&C strategies contribute to more efficient and visually appealing tree-map layouts. These papers offer valuable insights into utilising D\&C strategies for creating effective and scalable data visualizations. The work by Kostadinov et al.  \cite{10_kostadinov2022visual}  discusses a software tool designed to provide learners with two different visual representations of sorting algorithms. It also contains step-by-step visualisation of the algorithms along with visual representation of its time complexity.