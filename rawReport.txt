Section x - Methodology / Implemented work

1. Quicksort

How is it implemented?
i. Accepting input
ii. Repeated clicking on divide and conquer along with/or once click on solve until final result is achieved. 

The user is given the liberty to input the numbers. They can input as many numbers as needed and click 'Insert' button or press 'Enter/Return'. The numbers can either be either comma separated or space separated. On entering the numbers, grey rectangular bars are displayed on the screen whose height is equal to the value of the numbers. Once the user has entered all the numbers, they have two options - 'Divide' or 'Solve'. Clicking on 'Solve' will instantly display the final sorted array. However, if the user clicks on 'Divide', then the algorithm initially picks a pivot element using the 'Median of 3' approach. In this approach, the first, middle and the last element are placed in the sorted order and the median element is chosen. This becomes the pivot element to sort the array. The numbers of the arrays are then rearranged in such a way that all the numbers that are smaller than the pivot are placed on the left side of pivot and all numbers larger than the pivot are placed on the right side of pivot. After this, another set of bars are drawn based on the new arrangement of numbers but the pivot element is shaded with a different colour and placed with a slighly larger gap from all other elements. The colour of the pivot elements are based on the level of partition (level 0 - red, level 1 - blue, level 2 - green, level 3 - orange, level 4 - brown, level 5 - violet, level 6 - greenyellow). Level simply means how deep the partitions are made. For example, when the user clicks 'Divide' for the first time, it is called level 0, next click of 'Divide' is called level 1 and so on. Once a new set of bars are displayed below the original input bars, one can clearly see there are two groups of numbers separated by the pivot element. When the user clicks on 'Divide' again (level 1), each of these partitions is treated as a whole array and the same process is repeated, where a pivot is chosen, the numbers are rearranged, and new row of rectangular bars are drawn with all the pivots highlighted. Partitioning is possible as long as there is at least one subarray which has two or more elements in it. Partitioning stops when all the elements are chosen as pivot elements or there is just one element in each new partition. At this point the 'Divide' button is disabled and only 'Solve' button would still be enabled.

Clicking 'Solve' button at any point generates the solution from the partitions alreadt created. If it is clicked before 'Divide', then the web-app displays the final sorted array directly as there were no partitions created. When it is clicked after all the divide operations, then as the array was already sorted, it displays the same rectangular bars on the right hand side of the screen. As the array was already sorted, the solve button does nothing special here. At this point, the 'Solve' button is disabled and 'Conquer' button gets enabled. This is a but peculiar case, as when the last step of divide is reached, then the solution is actually obtained. But inorder to show how divide and conquer is applied, we separate the pivot elements with more space and a different colour in the divide phase and then revert them to grey colour and reduce the space at different levels in the conquer phase. When the user clicks on 'Conquer' the pivots selected in the corresponding divide step will be changed back to grey level and their gap will be reduced and the whole array is shown once again. So as the user clicks on 'Conquer' further, the pivots are removed one by one and at the last conquer step, the array will be shown in the fully sorted order with all grey bars meaning all the pivots are removed and that solution is perfectly sorted. 

To let the user know what happened at each step, there is a logs functionality. It displays the action that the user took and also shows the computational result that the computer perfoemed such as displaying which element was chosen as the pivot, what were the three numbers whose median turned out to be the pivot element. It also lists the insertion and deletion of numbers into the arrayin the logs so that the user is informed what action was performed. Then it also informs the user at what time the divide phase is complete. During the conquer phase, it lets the user know theough logs the partitions across which pivots were merged and also informs the user of the final conquer step where the array is successfully sorted. 

Not all users may be very well versed with quicksort. Hence to familiarise the users with quicksort and other functionalities of the web-app, there is an FAQs section as well. Clicking it gived the users informtion about quicksort, how the pivot os chosen in this case, how exactly is divide and conquer applied here and so on. It also explains about the different coloured bars and a few functionalities of the site such as different buttons, logs etc. Apart from that, there is also a 'Guide Me!' section which starts displaying the tooltips for the users regarding different buttons present on screen. They can navigate the tips in their own pace by using the left and right arrow depicting previous and next tups respectively. There is also a x button to close the tips fully. The tips also get closed when the user clicks on right arrow on the last tip. These tips can be invoked at any point in the execution of the program as it is important for the user to know what each button does to understand the tool fully. 

2. Convex hull

For any given point(s), its convex hull is the smallest set of points such that drawing a boundary around them encloses all the points forming a convex polygon. A convex polygon is a polygon where all interior angles are less than 180 degrees. This means all vertices point outwards and no interior angle “caves in”. Visually for humans, they can quickly identify the convex hull for any given set of points but it is not the case with the computer. To identify the convex hull, it recursively applies divide and conquer algorithms. The overall idea is that, the algo divides the set of points into smaller and smaller partitions using only perfect vertical lines until there are either one or two points in each partitions. In a special case of exactly vertical collinear points the partitions are allowed to have more then two points because it is not possible to divide them using a perfect vertical line. The base case convex hulls are either just a point or the line joining two points. In the special case mentioned above, the base case is the line joining all the vertical collinear points. 

So how are the partitions divided? So the algorithm takes all the points and then filters the sorted non repetitive x-coordinates. This is becasue the algorithm does not bother about the y-corrdinate of the points as yet. For example, we have points [5,2], [7,1], [7,2], [7,3], [9,1], [9,2] and [9,3]. What the algorithm initially does is that it seens the points having 7 as its x coordinates are all collinear and the points having 9 as its x coordinates are all collinear. Hence in its list of sorted non repetitive-x coordinates, it will only contain [5, 7, 9] because the points when projected on to the x axis consist of only these points. Then it creates a partition such that these non repetitive x-coordinates are split into two. If there are even elements, then the partitioning is exactly half and in case there are odd number of elements, then the partition on the right contains one more element  than on the left. In the case of our example, the splitting is done such that point with x-coordinate 5 will be on the left side of the partition line and points with 7 and 9 as their x coordinates will be on the right side of the partition lines. The partitioning lines are colour coded (red = level 0, blue = level 1, yellow = level 2 and cyan = level 3) and a red coloured dotted line will be drawn in beterrn 5 and 7 to highlight the partitioning line. If no more divide operations are possible, then the divide button gets disabled. However in this chosen example, one more divide is possible. The sorted non repetitive x coordinates is now [7, 9] because 5 is already just a point in the partition which means it has reached its base case. The splitting of [7, 9] happens by a vertical blue coloured dotted line drawn between those two numbers. Since all the points in 7 and 9 are collinear, we cannot divide any further and the divide phase ic complete. But if the divide could be still continued for some other examples, dotted partition lines will be drawn based on the level in which the division is happening. 

At this point the base case is reached and only the 'Solve' button will be enabled. Upon clicking the solve button, all the base case partitions are drawn. These include lines if the partition contains two points, or just a point if the partition contains only one point. At this point, even the solve button gets disabled and the conquer button gets enabled. Now, when the user clicks the conquer button, then all the convex hulls are merged in the reverse order in which they were created, and the hulls become bigger after each conquer operation. The in-focus partition lines and the base cases hulls will be brightly coloured and solid lines while the out-of-focus partition lines and hulls will be dull and dotted lines. At each conquer phase, the hulls drawn across each partition lines will be joined and its colour will be changed to the colour of the previous level. This repeatedly goes on until the final hull is drawn in green colour. 

As the grid is 11x11, there are 121 points the user can click on. Based on that, in level 0, there can be 1 partition. in level 1 ,there can be a maximum of two partitions. in level 2 there can be a maximum of 4 partitions and finally in level 3, there can be a maximum of 8 partitions but since we are having only 10 spaces to create partitions, in the last level there can be only 3 more (despite it can have 8 technically). 

How are the hulls merged and what is the algorithm used for that?
At each merge phase, there will be two sets of points. The algorithm then selects the rightmost point in the left set (lets call this point pt1) and the leftmost point in the right set (lets call this pt2). Then it keeps pt1 and pt2 fixed and iterates through all the points in the right set to check if there is any point such that the line joining pt1, pt2 and new point x takes a left turn as shown in the figure. If the line takes a left turn, then pt2 will be the new point and it iterates through all the points of the second set again. The goal of this is to find the topmost point in the righthand side set of points. Once it iterates theough all the points in the right set and comes out of the loop, pt2 will have the topmost point of the set. Now keeping pt1 and pt2 fixed, it iterates through all the points in the left set. If the line joining pt2, pt1 and the new point takes a right turn, then the new point will be updated as pt1 and the process is repeated for all the points in the left set. The loop is broken when there is no change in pt1 after scanning the entire left set of points. At this point pt1 will have the topmost point in the left set. pt1 and pt2 not represent the top tangent of the two convex hulls meaning the line pasing through these two points will not have any points above them. 
Now the same structure of the loop is repeated but this time, in the right set, the new point will be updated as pt2 if the line joining pt1, pt2 and the new point takes a right turn(opposite of what we did to find the top tangent point in the right set). In the left set, the new point gets updated as pt1 when the line joining pt1, pt2 and new point take a left turn(again, its the opposite of what we did to find the top tangent in the left set). After finishing this loop, pt1 and pt2 will be the vertices of bottom tangents of the twosets of points. This means all the vertices are now present above this bottom tangent and below the top tangent. We have found the top and bottom tangents but now need to check if we have any points to the left and right of these end points. These 4 points now form a quadrilateral. Next we iterate through all the points to check if they are inside the quadrilateral or not. While chekcing if we find that they are completely inside the polygon or even on the edges of the polygon, then we can safely ignore it as they will be enclosed by the polygon lines. If any point is strictly outside the polygon, then that point will be a part of the convex hull's edge. We replace the left and right hull set points in the original coordinates-array with the points forming the hull. The same process is repeated upon every click of conquer until there is just one set of points presenrt in the coordinates array. 
Sometimes, when joining two hulls, it can happen that instead of having 4 points, we end up with only 3 points end points. In such a case, instead of forming a quadrilateral, we form a triangle. The upper and lower tangent points for one of the set of points end up being the same as shown in the figure x. But the process can be continues as is. If the top and bottom tangents converge to a single point, it means that there is no other point above or below it. There also wont exist a point to the left of it (if this point is in the left set) or on the right (if this point belongs to the right set). 

Just like in the quicksort, there is logs functionality here as well. Each time a user clicks on a coordinate to enter it, a log message gets displayed to inform the user that the point is added to the array. Similarly, when the user clicks on the same point again, then it gets deleted and a corresponding delete message gets displayed. However, if the user clicks anywhere other than the actual points, then a error message gets displayed to let the user know that the point is not registered and asks the user to click closer to the intersection of the lines. At each divide phase, it displays the x coordinate in which the divide happens and similarly it displays the x coordinate across which the partitions were merged. It also displays the success messages when the division phase is completed and the merge phase is also completed. 

This also has the FAQs page to tell the users more about convex hulls and how divide and conquer algorithm is applied here. Also there is a 'Guide Me!' button using which the users can know what exactly is the functionality of different buttons present in the visualiser. And a reset button to reset the entire interface. In the visualiser interface, sime buttons get enabled and disabled according to the situation. 


